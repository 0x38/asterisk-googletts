#!/usr/bin/env perl

#
# AGI script that uses Google's translate text to speech engine.
#
# Copyright (C) 2011, Lefteris Zafiris <zaf.000@gmail.com>
#
# This program is free software, distributed under the terms of
# the GNU General Public License Version 2. See the COPYING file
# at the top of the source tree.
#
# -----
# Usage
# -----
# agi(googletts.agi,"text",[language],[intkey]): This will invoke the Google TTS engine,
# render the text string to speech and play it back to the user. If 'intkey' is set the
# script will wait for user input. Any given interrupt keys will cause the playback
# to immediately terminate and the dialplan to proceed to the matching extension
# (this is mainly for use in IVR, see README for examples).
#
# The script contacts google's TTS service in order to get the voice data
# which then stores in a local cache (by default /tmp/) for future use.
#
# Parameters like default language, sample rate, caching and cache dir
# can be set up by altering the following variables:
# Default langeuage: $lang
# Sample rate:       $samplerate
# Chace:             $usecache
# Chache directory:  $cachedir
#

use warnings;
use strict;
use File::Temp qw(tempfile);
use File::Copy qw(copy);
use File::Path qw(mkpath);
use Digest::MD5 qw(md5_hex);
use File::Temp qw(tempfile);
use CGI::Util qw(escape unescape);
use LWP::UserAgent;

$| = 1;

# ----------------------------- #
#   User defined parameters:    #
# ----------------------------- #
# Default language              #
my $lang = "en";

# Output audio sample rate      #
my $samplerate = 8000;

# Use of cache mechanism        #
my $usecache = 1;

# Cache directory path          #
my $cachedir = "/tmp";

# Verbose debugging messages    #
my $debug = 0;

# ----------------------------- #

my %AGI;
my @text;
my $line;
my $input;
my $res;
my $fh;
our $tmpname;
my $filename;
my $fexten;
my $request;
my $response;
my @result;
my $scriptname;
my $intkey  = "";
my $tmpdir  = "/tmp";
my $timeout = 5000;
my $url     = "http://translate.google.com/translate_tts";
my $sox     = `/usr/bin/which sox`;
my $mpg123  = `/usr/bin/which mpg123`;

# Store AGI input #
while (<STDIN>) {
	chomp;
	last if (!length($_));
	$AGI{$1} = $2 if (/^agi_([a-z]+)\:\s+(.*)$/);
}
($AGI{arg_1}, $AGI{arg_2}, $AGI{arg_3}) = @ARGV;

$scriptname = " -- $AGI{request}:";

if ($debug) {
	print STDERR "$scriptname AGI Environment Dump:\n";
	print STDERR " -- $_ = $AGI{$_}\n" foreach (sort keys %AGI);
}

# Check for required programs #
if (!$sox || !$mpg123) {
	print STDERR "$scriptname sox or mpg123 is missing. Aborting.\n";
	exit 1;
} else {
	chomp($sox);
	print STDERR "$scriptname sox found in: $sox\n" if ($debug);
	chomp($mpg123);
	print STDERR "$scriptname mpg123 found in: $mpg123\n" if ($debug);
}

# Sanitising input #
$AGI{arg_1} =~ s/[\\\/|*~<>^\(\)\[\]\{\}\r\n]/ /g;
$AGI{arg_1} =~ s/\s+/ /g;
$AGI{arg_1} =~ s/^\s|\s$//g;
if (!length($AGI{arg_1})) {
	print STDERR "$scriptname No text passed for synthesis.\n";
	exit 1;
} else {
	# Split input to comply with google tts requirements #
	$AGI{arg_1} .= ".";
	@text = $AGI{arg_1} =~ /.{1,100}[.,!?;:]|.{1,100}\s/g;
}

# Setting language #
if (length($AGI{arg_2})) {
	$lang = $AGI{arg_2} if ($AGI{arg_2} =~ /^[a-z]{2}(-[a-zA-Z]{2,6})?$/);
}

# Setting interrupt keys #
if (length($AGI{arg_3})) {
	$intkey = "0123456789#*" if ($AGI{arg_3} eq "any");
	$intkey = $AGI{arg_3} if ($AGI{arg_3} =~ /^[0-9*#]+$/);
}

# Setting filename extension according to sample rate. #
if ($samplerate == 16000) {
	$fexten = "sln16";
} else {
	$fexten     = "sln";
	$samplerate = 8000;
}

# Check cache path size #
if ($usecache && ((length($cachedir) + 38) > 2048)) {
	print STDERR "$scriptname Cache path size exceeds limit. Disabling cache.\n";
	$usecache = 0;
}

# Answer channel if not already answered #
print "CHANNEL STATUS\n";
$input  = <STDIN>;
@result = &checkinput($input);
if ($result[0] == 4) {
	print "ANSWER\n";
	$input = <STDIN>;
	&checkinput($input);
}

# Get digit timeout #
print "GET VARIABLE TIMEOUT(digit)\n";
$input  = <STDIN>;
@result = &checkinput($input);
if ($result[0] == 1) {
	$result[1] =~ s/[\(\)]//g;
	$timeout = $result[1] * 1000;
}

my $ua = LWP::UserAgent->new;
$ua->agent("Mozilla/5.0 (X11; Linux; rv:8.0) Gecko/20100101");
$ua->timeout(5);

foreach $line (@text) {
	$line =~ s/^\s+|\s+$//g;
	last if (length($line) == 0);
	if ($debug) {
		print STDERR "$scriptname Text passed for synthesis: $line\n",
			"$scriptname Language: $lang, Interrupt keys: $intkey, Sample rate: $samplerate\n",
			"$scriptname Timeout (ms): $timeout, Caching: $usecache, Cache dir: $cachedir\n";
	}
	if ($usecache) {
		$filename = md5_hex($line);
		# Stream file from cache if it exists #
		if (-r "$cachedir/$filename.$fexten") {
			print STDERR "$scriptname File already in cache.\n" if ($debug);
			$res = &playback("$cachedir/$filename", $intkey);
			last if ($res > 0);
			next;
		}
	}
	$line = escape($line);
	print STDERR "$scriptname URL passed: $url?tl=$lang&q=$line\n" if ($debug);
	$request = HTTP::Request->new('GET' => "$url?tl=$lang&q=$line");
	$response = $ua->request($request);
	if (!$response->is_success) {
		print STDERR "$scriptname Failed to fetch file.\n";
		exit 1;
	} else {
		$SIG{'HUP'} = \&hup_handler;
		($fh, $tmpname) = tempfile("ggl_XXXXXX", DIR => $tmpdir, UNLINK => 1);
		open($fh, ">", "$tmpname.mp3") or die "$scriptname Cannot wtite to file: $!";
		print $fh $response->content;
		close $fh;
		# Convert mp3 file to 16bit 8Khz mono raw #
		system($mpg123, "-q", "-w", $tmpname . ".wav", $tmpname . ".mp3");
		if ($? == -1) {
			print STDERR "$scriptname Failed to execute mpg123: $!\n";
			unlink glob "$tmpname*";
			exit 1;
		}
		system($sox, $tmpname . ".wav", "-r", $samplerate, "-t", "raw", "$tmpname.$fexten");
		if ($? == -1) {
			print STDERR "$scriptname Failed to execute sox: $!\n";
			unlink glob "$tmpname*";
			exit 1;
		}
		$res = &playback($tmpname, $intkey);
		# Save file in cache #
		if ($usecache) {
			mkpath("$cachedir") if (!(-d "$cachedir"));
			print STDERR "$scriptname Saving file $filename to cache\n" if ($debug);
			copy("$tmpname.$fexten", "$cachedir/$filename.$fexten");
		}
		unlink glob "$tmpname*";
		last if ($res > 0);
	}
}

if ($intkey ne "" && $res == 0) {
	print STDERR "$scriptname Waiting for digits.\n" if ($debug);
	print "WAIT FOR DIGIT $timeout\n";
	$input  = <STDIN>;
	@result = &checkinput($input);
	if ($result[0] > 0) {
		print STDERR "$scriptname Digit ", chr($result[0]), " was pressed.\n" if ($debug);
		print "SET EXTENSION ", chr($result[0]), "\n";
		print "SET PRIORITY 1\n";
	}
}
exit;

sub checkinput {
	my ($inpt) = @_;
	my @values;

	chomp $inpt;
	if ($inpt =~ /^200/) {
		$inpt =~ /result=(-?\d+)\s?(.*)$/;
		if (!length($1)) {
			print STDERR "$scriptname Command failed: $inpt\n";
			@values = ("-1");
		} else {
			print STDERR "$scriptname Command returned: $inpt\n" if ($debug);
			@values = ("$1", "$2");
		}
	} else {
		print STDERR "$scriptname Unexpected result: $inpt\n";
		@values = ("-1");
	}
}

sub playback {
	my ($file, $keys) = @_;
	my $response;
	my @result;

	print "STREAM FILE $file \"$keys\"\n";
	$response = <STDIN>;
	@result   = &checkinput($response);
	if ($result[0] >= 32) {
		print STDERR "$scriptname Digit ", chr($result[0]), " was pressed.\n" if ($debug);
		print "SET EXTENSION ", chr($result[0]), "\n";
		print "SET PRIORITY 1\n";
		return $result[0];
	} elsif ($result[0] == -1) {
		print STDERR "$scriptname Failed to play $file.\n";
		return -1;
	}
	return 0;
}

sub hup_handler {
	unlink glob "$tmpname*";
	die "$scriptname HUP signal received, terminating...\n";
}
